-------------------------------------------------------------------------------
-- The Jeff Paradox - Game State Package Body
-------------------------------------------------------------------------------

with Ada.Text_IO;           use Ada.Text_IO;
with Ada.Strings.Fixed;     use Ada.Strings.Fixed;
with Ada.Directories;       use Ada.Directories;
with Ada.Integer_Text_IO;   use Ada.Integer_Text_IO;

package body Game_State is

   ---------------------------------------------------------------------------
   -- Load_State: Read game state from YAML file
   ---------------------------------------------------------------------------
   procedure Load_State (Path : String := To_String (State_File_Path)) is
      File : File_Type;
      Line : String (1 .. 256);
      Last : Natural;
   begin
      if not Exists (Path) then
         Put_Line ("State file not found: " & Path);
         Current_State.Is_Loaded := False;
         return;
      end if;

      Open (File, In_File, Path);

      while not End_Of_File (File) loop
         Get_Line (File, Line, Last);
         declare
            L : constant String := Line (1 .. Last);
         begin
            --  Simple YAML parsing (key: value format)
            if Index (L, "turn_number:") > 0 then
               Current_State.Turn_Number :=
                 Natural'Value (L (Index (L, ":") + 1 .. Last));
            elsif Index (L, "chaos:") > 0 then
               Current_State.Chaos :=
                 Natural'Value (L (Index (L, ":") + 1 .. Last));
            elsif Index (L, "exposure:") > 0 then
               Current_State.Exposure :=
                 Natural'Value (L (Index (L, ":") + 1 .. Last));
            elsif Index (L, "faction_slider:") > 0 then
               Current_State.Faction_Slider :=
                 Integer'Value (L (Index (L, ":") + 1 .. Last));
            elsif Index (L, "current_node:") > 0 then
               if Index (L, "alpha") > 0 then
                  Current_State.Current_Node := Alpha;
               else
                  Current_State.Current_Node := Beta;
               end if;
            end if;
         end;
      end loop;

      Close (File);
      Current_State.Is_Loaded := True;
      Put_Line ("State loaded successfully from " & Path);

   exception
      when others =>
         if Is_Open (File) then
            Close (File);
         end if;
         Put_Line ("Error loading state file");
         Current_State.Is_Loaded := False;
   end Load_State;

   ---------------------------------------------------------------------------
   -- Save_State: Write game state to YAML file
   ---------------------------------------------------------------------------
   procedure Save_State (Path : String := To_String (State_File_Path)) is
      File : File_Type;
   begin
      Create (File, Out_File, Path);

      Put_Line (File, "# The Jeff Paradox - Game State");
      Put_Line (File, "# Auto-generated by Ada TUI");
      Put_Line (File, "");
      Put (File, "turn_number: ");
      Put (File, Current_State.Turn_Number, Width => 0);
      New_Line (File);
      Put (File, "chaos: ");
      Put (File, Current_State.Chaos, Width => 0);
      New_Line (File);
      Put (File, "exposure: ");
      Put (File, Current_State.Exposure, Width => 0);
      New_Line (File);
      Put (File, "faction_slider: ");
      Put (File, Current_State.Faction_Slider, Width => 0);
      New_Line (File);
      Put (File, "current_node: ");
      Put_Line (File, (if Current_State.Current_Node = Alpha
                       then "alpha" else "beta"));

      Close (File);
      Put_Line ("State saved to " & Path);

   exception
      when others =>
         if Is_Open (File) then
            Close (File);
         end if;
         Put_Line ("Error saving state file");
   end Save_State;

   ---------------------------------------------------------------------------
   -- Reset_State: Initialize to default values
   ---------------------------------------------------------------------------
   procedure Reset_State is
   begin
      Current_State := (Turn_Number    => 0,
                        Chaos          => 0,
                        Exposure       => 0,
                        Faction_Slider => 0,
                        Current_Node   => Alpha,
                        Is_Loaded      => True);
   end Reset_State;

   ---------------------------------------------------------------------------
   -- Modifiers
   ---------------------------------------------------------------------------
   procedure Increment_Chaos (Amount : Natural := 1) is
   begin
      Current_State.Chaos :=
        Natural'Min (Current_State.Chaos + Amount, Max_Chaos);
   end Increment_Chaos;

   procedure Increment_Exposure (Amount : Natural := 1) is
   begin
      Current_State.Exposure :=
        Natural'Min (Current_State.Exposure + Amount, Max_Exposure);
   end Increment_Exposure;

   procedure Adjust_Faction (Delta : Integer) is
      New_Value : constant Integer := Current_State.Faction_Slider + Delta;
   begin
      Current_State.Faction_Slider :=
        Integer'Max (Min_Faction, Integer'Min (New_Value, Max_Faction));
   end Adjust_Faction;

   procedure Switch_Node is
   begin
      Current_State.Current_Node :=
        (if Current_State.Current_Node = Alpha then Beta else Alpha);
   end Switch_Node;

   procedure Advance_Turn is
   begin
      Current_State.Turn_Number := Current_State.Turn_Number + 1;
      Switch_Node;
   end Advance_Turn;

   ---------------------------------------------------------------------------
   -- Queries
   ---------------------------------------------------------------------------
   function Chaos_Warning return Boolean is
   begin
      return Current_State.Chaos >= Chaos_Warning_Threshold;
   end Chaos_Warning;

   function Exposure_Warning return Boolean is
   begin
      return Current_State.Exposure >= Exposure_Warning_Threshold;
   end Exposure_Warning;

   function Faction_Critical return Boolean is
   begin
      return abs (Current_State.Faction_Slider) >= Faction_Critical_Threshold;
   end Faction_Critical;

   function Get_Status_Line return String is
      Node_Str : constant String :=
        (if Current_State.Current_Node = Alpha then "Alpha" else "Beta");
   begin
      return "Turn:" & Natural'Image (Current_State.Turn_Number) &
             " | Chaos:" & Natural'Image (Current_State.Chaos) &
             "/100 | Exposure:" & Natural'Image (Current_State.Exposure) &
             "/100 | Faction:" & Integer'Image (Current_State.Faction_Slider) &
             " | Node: " & Node_Str;
   end Get_Status_Line;

   function Check_Thresholds return Threshold_Event is
   begin
      if Current_State.Chaos >= Chaos_Warning_Threshold then
         return Chaos_High;
      elsif Current_State.Exposure >= Exposure_Warning_Threshold then
         return Exposure_High;
      elsif Current_State.Faction_Slider >= Faction_Critical_Threshold then
         return Faction_Starbound;
      elsif Current_State.Faction_Slider <= -Faction_Critical_Threshold then
         return Faction_Earthbound;
      else
         return None;
      end if;
   end Check_Thresholds;

end Game_State;
